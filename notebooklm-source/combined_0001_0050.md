
# 0001. Two Sum

```python
'''
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
'''

from typing import List

# Using Hash Tables

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict = {}
        for i in range(len(nums)):
            temp = target-nums[i]
            if temp in dict:
                return [dict[temp], i]
            dict.update({nums[i] : i})

# Using Hash Tables (New)

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for index, num in enumerate(nums):
            if target - num in d.keys():
                return [d[target - num], index]
            else:
                d[num] = index

# Check Custom Input

s = Solution()
answer = s.twoSum([3,2,1,5], 8) # Testing [0,3]
print(answer)
```
# 0002. Add Two Numbers

```python
'''
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
'''

# Definition for singly-linked list.

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        cur = res = ListNode()
        carry = 0
        while l1 or l2 or carry:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            carry, value = carry // 10, carry % 10
            cur.next = ListNode(value)
            cur = cur.next
        return res.next

# Check Custom Input

s = Solution()

l1_node1 = ListNode(2)
l1_node2 = ListNode(4)
l1_node3 = ListNode(3)

l1_node1.next = l1_node2
l1_node2.next = l1_node3

l2_node1 = ListNode(5)
l2_node2 = ListNode(6)
l2_node3 = ListNode(4)

l2_node1.next = l2_node2
l2_node2.next = l2_node3

answer = s.addTwoNumbers(l1_node1, l2_node1)

while answer:
    print(answer.val)
    answer = answer.next
```
# 0003. Longest Substring Without Repeating Characters

```python
'''
Given a string, find the length of the longest substring without repeating characters.

Example 1:

Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 

Example 2:

Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:

Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
'''

from typing import List

# Two Pointers and Hash Set

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = right = maxx = 0
        
        char = set()
        
        while right < len(s):
            if s[right] in char:
                char.remove(s[left])
                left += 1
            else:
                char.add(s[right])
                right += 1
                maxx = max(len(char), maxx)
        
        return maxx

# Two Pointers and Hash Table

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = right = max_len = 0
        d = {}
        while left < len(s) and right < len(s):
            if s[right] in d:
                left = max(left, d[s[right]] + 1)
            d[s[right]] = right
            max_len = max(max_len, right - left + 1)
            right += 1
        return max_len

# Custom Input Check

s = Solution()
answer = s.lengthOfLongestSubstring("nishant") # 6
print(answer)
```
# 0004. Median of Two Sorted Arrays

```python
'''
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0

Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
'''
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        if not n:
            return
        
        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j - 1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i - 1] > nums2[j]:
                imax = i - 1
            else:
                if not i:
                    max_left = nums2[j - 1]
                elif not j:
                    max_left = nums1[i - 1]
                else:
                    max_left = max(nums1[i - 1], nums2[j - 1])
                    
                if (m + n) % 2 == 1:
                    return max_left
                
                if i == m:
                    min_right = nums2[j]
                elif j == n:
                    min_right = nums1[i]
                else:
                    min_right = min(nums1[i], nums2[j])
                    
                return (max_left + min_right) / 2.0

```
# 0005. Longest Palindromic Substring

```python
'''
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.

Example 2:

Input: "cbbd"
Output: "bb"
'''
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        start = end = 0
        
        for i in range(len(s)):
            length = self.expand_from_mid(s, i, i)
            length1 = self.expand_from_mid(s, i, i + 1)
            length = max(length, length1)
            if length > end - start:
                start = i - (length - 1) // 2
                end = i + length // 2
        
        return s[start : end + 1]
        
    def expand_from_mid(self, s, left, right):
        
        while left >= 0 and right <  len(s) and s[left] == s[right]:
            left -= 1
            right += 1
            
        return right - left - 1
```
# 0006. ZigZag Conversion

```python
'''
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
'''
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        
        res = ''
        n = len(s)
        cycle_len = 2 * numRows - 2
        
        for i in range(numRows):
            j = 0
            while j + i < n:
                res += s[j + i]
                if i != 0 and i != numRows - 1 and j + cycle_len - i < n:
                    res += s[j + cycle_len - i]
                j += cycle_len
        return res

```
# 0007. Reverse Integer

```python
# https://leetcode.com/problems/reverse-integer/
#
# Given a 32-bit signed integer, reverse digits of an integer.
#
# Example 1:
#
# Input: 123
# Output: 321
# Example 2:
#
# Input: -123
# Output: -321
# Example 3:
#
# Input: 120
# Output: 21
# Note:
# Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
#

class Solution:
  def reverse(self, x: int) -> int:
    sign = -1 if x < 0 else 1
    x = abs(x)
    rev = 0
    while x != 0:
      pop = x % 10
      x //= 10
      rev = rev * 10 + pop
    
    rev = sign * rev
    if rev > 2**31 - 1 or rev < -2**31:
      return 0
    return rev

```
# 0008. String to Integer atoi

```python
# https://leetcode.com/problems/string-to-integer-atoi/
#
# Implement atoi which converts a string to an integer.
#
# The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.
#
# The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.
#
# If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.
#
# If no valid conversion could be performed, a zero value is returned.
#
# Note:
#
# Only the space character ' ' is considered as whitespace character.
# Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.
#
class Solution:
    def myAtoi(self, str: str) -> int:
        str = str.strip()
        if not str:
            return 0

        sign = 1
        i = 0
        if str[i] == '+':
            i += 1
        elif str[i] == '-':
            sign = -1
            i += 1

        num = 0
        while i < len(str) and str[i].isdigit():
            num = num * 10 + int(str[i])
            i += 1

        num *= sign

        if num > 2**31 - 1:
            return 2**31 - 1
        if num < -2**31:
            return -2**31
        
        return num

```
# 0009. Palindrome Number

```python
#https://leetcode.com/problems/palindrome-number/

# Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

# Example 1:
# Input: 121
# Output: true

# Example 2:
# Input: -121
# Output: false
# Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

# Example 3:
# Input: 10
# Output: false
# Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

# Follow up:
# Coud you solve it without converting the integer to a string?

# Method 1 (Meeting in the Middle and Comparing)

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if (x<0 or (x%10 == 0 and x!=0)): #Negative or Ending with 0 but not 0 cases
            return False
        rev = 0
        while(x>rev):
            rev = (rev*10)+(x%10)
            x=x//10
        return rev==x or rev//10==x #Removing middle digit from a number with odd length using rev//10
        
# Method 2 (Reversing and Comparing)

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x != 0 and not (x % 10)):
            return False
        integer, res = x, 0
        while integer > 0:
            res = res * 10 + (integer % 10)
            integer //= 10
            print(res)
        return res == x
```
# 0010. Regular Expression Matching

```python
# https://leetcode.com/problems/regular-expression-matching/
#
# Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.
#
# '.' Matches any single character.
# '*' Matches zero or more of the preceding element.
# The matching should cover the entire input string (not partial).
#
# Note:
#
# s could be empty and contains only lowercase letters a-z.
# p could be empty and contains only lowercase letters a-z, and characters like . or *.
#
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        dp[-1][-1] = True
        for i in range(len(s), -1, -1):
            for j in range(len(p) - 1, -1, -1):
                first_match = i < len(s) and p[j] in {s[i], '.'}
                if j + 1 < len(p) and p[j+1] == '*':
                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]
                else:
                    dp[i][j] = first_match and dp[i+1][j+1]
        return dp[0][0]

```
# 0011. Container With Most Water

```python
'''
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

Example:

Input: [1,8,6,2,5,4,8,3,7]
Output: 49
'''

from typing import List

# Two Pointers

class Solution:
    def maxArea(self, height: List[int]) -> int:
        start, end, max_area = 0, len(height) - 1 , 0
        while start < end:
            max_area = max((end - start) * min(height[start], height[end]), max_area)
            if height[start] < height[end]:
                start += 1
            else:
                end -= 1
        return max_area

# Custom Input Check

s = Solution()
answer = s.maxArea([2, 1, 1, 2]) # 6
print(answer)
```
# 0012. Integer to Roman

```python
'''
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

    I can be placed before V (5) and X (10) to make 4 and 9. 
    X can be placed before L (50) and C (100) to make 40 and 90. 
    C can be placed before D (500) and M (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: "III"

Example 2:

Input: 4
Output: "IV"

Example 3:

Input: 9
Output: "IX"

Example 4:

Input: 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.

Example 5:

Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
'''
class Solution:
    def intToRoman(self, num: int) -> str:
        d = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'} 
        
        res = ''
        
        for i in d:
            res += (num // i) * d[i]
            num %= i
        
        return res

```
# 0013. Roman to Integer

```python
'''
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

    I can be placed before V (5) and X (10) to make 4 and 9. 
    X can be placed before L (50) and C (100) to make 40 and 90. 
    C can be placed before D (500) and M (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: "III"
Output: 3

Example 2:

Input: "IV"
Output: 4

Example 3:

Input: "IX"
Output: 9

Example 4:

Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.

Example 5:

Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
'''
# Time Complexity: O(n)
# Space Complexity: O(1)

# Method 1

class Solution:
    def romanToInt(self, s: str) -> int:
        
        symbol_value = {'I' : 1, 'V' : 5, 'X' : 10, 'L' : 50, 'C' : 100, 'D' : 500, 'M' : 1000}
        
        result = 0
        
        for i in range(len(s)):
            
            if i > 0 and symbol_value[s[i]] > symbol_value[s[i - 1]]:
                
                result += symbol_value[s[i]] - 2 * (symbol_value[s[i - 1]])
            
            else:
                
                result += symbol_value[s[i]]
                
        return result

# Method 2 (Checking the value of next character and subtracting if more than the current character and adding if less)

class Solution:
    def romanToInt(self, s: str) -> int:
        roman_numerals = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
        
        res = 0
        for index in range(len(s) - 1):
            if roman_numerals[s[index]] < roman_numerals[s[index + 1]]:
                res -= roman_numerals[s[index]]
            else:
                res += roman_numerals[s[index]]
        return res + roman_numerals[s[-1]]
```
# 0014. Longest Common Prefix

```python
'''
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

 

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
 

Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters.
'''

# Method 1 (Comparing each String)

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        lcp = strs[0]
        for index in range(1, len(strs)):
            lcp = self.sub_compare(lcp, strs[index])
            if not lcp:
                return ""
        return lcp
        
    def sub_compare(self, s1, s2):
        res = ""
        if len(s2) < len(s1):
            s1, s2 = s2, s1
        for index, char in enumerate(s1):
            if char == s2[index]:
                res += char
            else:
                break
        return res
```
# 0015. 3Sum

```python
# https://leetcode.com/problems/3sum/
#
# Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
#
# Note:
#
# The solution set must not contain duplicate triplets.
#
class Solution:
    def threeSum(self, nums: list[int]) -> list[list[int]]:
        nums.sort()
        res = []
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            l, r = i + 1, len(nums) - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s < 0:
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    res.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res

```
# 0016. 3Sum Closest

```python
# https://leetcode.com/problems/3sum-closest/
#
# Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
#
class Solution:
    def threeSumClosest(self, nums: list[int], target: int) -> int:
        nums.sort()
        res = sum(nums[:3])
        for i in range(len(nums) - 2):
            l, r = i + 1, len(nums) - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if abs(s - target) < abs(res - target):
                    res = s
                if s < target:
                    l += 1
                elif s > target:
                    r -= 1
                else:
                    return res
        return res

```
# 0017. Letter Combinations of a Phone Number

```python
'''
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.
'''

# Method1 using Backtracking

class Solution:
    
    def backtrack(self, res, m, digits, combination, index):
        if index > len(digits):
            return
        if len(combination) == len(digits):
            res.append(combination)
            return
        cur_digit = digits[index]
        cur_string = m[cur_digit]
        for s in cur_string:
            self.backtrack(res, m, digits, combination + s, index + 1)
    
    def letterCombinations(self, digits: str) -> List[str]:
        res = []
        if not digits:
            return res
        
        m = {'2' : 'abc', '3' : 'def', '4' : 'ghi', '5' : 'jkl', '6' : 'mno', '7' : 'pqrs', '8' : 'tuv', '9' : 'wxyz'}
        
        self.backtrack(res, m, digits, '', 0)
        
        return res

# Method 2 using Backtracking but shorthand 

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        res = []
        
        if not digits:
            return res
        
        mapping = {'2': ['a', 'b', 'c'],
                 '3': ['d', 'e', 'f'],
                 '4': ['g', 'h', 'i'],
                 '5': ['j', 'k', 'l'],
                 '6': ['m', 'n', 'o'],
                 '7': ['p', 'q', 'r', 's'],
                 '8': ['t', 'u', 'v'],
                 '9': ['w', 'x', 'y', 'z']}
        
        def backtrack(combination, next_digits):
            if not next_digits:
                res.append(combination)
            else:
                for letter in mapping[next_digits[0]]:
                    backtrack(combination + letter, next_digits[1:])
                    
        backtrack("", digits)
        return res
```
# 0018. 4Sum

```python
# https://leetcode.com/problems/4sum/
#
# Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
#
# Note:
#
# The solution set must not contain duplicate quadruplets.
#
class Solution:
    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:
        def findNsum(nums, target, N, result, results):
            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:
                return
            if N == 2:
                l,r = 0,len(nums)-1
                while l < r:
                    s = nums[l] + nums[r]
                    if s == target:
                        results.append(result + [nums[l], nums[r]])
                        l += 1
                        while l < r and nums[l] == nums[l-1]:
                            l += 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
            else:
                for i in range(len(nums)-N+1):
                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):
                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)

        results = []
        findNsum(sorted(nums), target, 4, [], results)
        return results

```
# 0019. Remove Nth Node From End of List

```python
'''
Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?
'''
# Definition for singly-linked list.

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        first = last = head
        for _ in range(n):
            last = last.next
        if not last:
            return first.next
        while last.next:
            last = last.next
            first = first.next
        first.next = first.next.next
        return head

# Check Custom Input

s = Solution()

node1 = ListNode(1)
node2 = ListNode(3)
node3 = ListNode(5)
node4 = ListNode(7)

node1.next = node2
node2.next = node3
node3.next = node4

answer = s.removeNthFromEnd(node1, 2) # 1 => 3 => 7

while answer:
    print(answer.val)
    answer = answer.next
```
# 0020. Valid Parentheses

```python
'''
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true
'''

# Time Complexity: O(n)
# Space Complexity: O(n)

# Solution using Stack

class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        parens = {'(' : ')', '{' : '}', '[' : ']'}
        stack = []
        for paren in s:
            if paren in parens.keys():
                stack.append(paren)
            elif not stack or paren != parens[stack.pop()]:
                return False
        return not stack
```
# 0021. Merge Two Sorted Lists

```python
'''
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
'''

# Definition for singly-linked list.

class ListNode:
    def __init__(self, val = 0, next = None):
        self.val = val
        self.next = None

#Iterative
#Time Complexity - O(n+m), Space Complexity - O(1)

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        cur_node = pre_node = ListNode()
        while list1 and list2:
            if list1.val < list2.val:
                cur_node.next = list1
                list1 = list1.next
            else:
                cur_node.next = list2
                list2 = list2.next
            cur_node = cur_node.next
        cur_node.next = list1 if list1 else list2
        return pre_node.next

#Recursive
#Time Complexity - O(n+m), Space Complexity - O(n+m)

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1 or not l2: return l1 or l2
        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l2.next, l1)
            return l2

# Custom Input Check 

s = Solution()

l1_1 = ListNode(1)
l1_2 = ListNode(2)
l1_3 = ListNode(4)

l1_1.next = l1_2
l1_2.next = l1_3

# l1: 1 => 2 => 4

l2_1 = ListNode(1)
l2_2 = ListNode(3)
l2_3 = ListNode(4)

l2_1.next = l2_2
l2_2.next = l2_3

# l2: 1 => 3 => 4

answer = s.mergeTwoLists(l1_1, l2_1)

while answer:
    print(answer.val)
    answer = answer.next
```
# 0022. Generate Parentheses

```python
'''
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
'''
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        
        def backtrack(res, s, opening, closing, max_pairs):
            if len(s) == max_pairs * 2:
                res.append(s)
                return
            if opening < max_pairs:
                backtrack(res, s + '(', opening + 1, closing, max_pairs)
            if closing < opening:
                backtrack(res, s + ')', opening, closing + 1, max_pairs)
        
        backtrack(res, "", 0, 0, n)
        return res
```
# 0023. Merge k Sorted Lists

```python
'''
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
'''

# Definition for singly-linked list.

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

# Method 1

class Solution:
    
    def mergeTwoLists(self, l1, l2):
        res = cur = ListNode()
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 or l2
        return res.next
        
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        last = len(lists) - 1
        while last:
            i, j = 0, last
            while i < j:
                lists[i] = self.mergeTwoLists(lists[i], lists[j])
                i += 1
                j -= 1
                last -= 1
        return lists[0]

# Method 2

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        last = len(lists) - 1
        while last:
            i, j = 0, last
            while i < j:
                res = cur = ListNode()
                first, second = lists[i], lists[j]
                while first and second:
                    if first.val <= second.val:
                        cur.next = first
                        first = first.next
                    else:
                        cur.next = second
                        second = second.next
                    cur = cur.next
                cur.next = first or second
                lists[i] = res.next
                i += 1
                j -= 1
                last -= 1
        return lists[0]
```
# 0024. Swap Nodes in Pairs

```python
'''
Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

 

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.
'''
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        temp = ListNode()
        temp.next = head
        cur = temp
        
        while cur.next and cur.next.next:
            cur.next.next, cur.next, cur.next.next = cur.next.next.next, cur.next.next, cur.next
            cur = cur.next.next
        
        return temp.next

```
# 0025. Reverse Nodes in k Group

```python
# https://leetcode.com/problems/reverse-nodes-in-k-group/
#
# Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
#
# k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
#
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = ListNode(0, head)
        groupPrev = dummy

        while True:
            kth = self.getKth(groupPrev, k)
            if not kth:
                break
            
            groupNext = kth.next
            
            # reverse group
            prev, curr = kth.next, groupPrev.next

            while curr != groupNext:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp
            
            tmp = groupPrev.next
            groupPrev.next = kth
            groupPrev = tmp

        return dummy.next

    def getKth(self, curr, k):
        while curr and k > 0:
            curr = curr.next
            k -= 1
        return curr

```
# 0026. Remove Duplicates from Sorted Array

```python
'''
Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
'''
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums: return 0
        pre, nex = 0, 1
        while nex < len(nums):
            if nums[nex] != nums[pre]:
                pre += 1
                nums[pre] = nums[nex]
            nex += 1
        return pre + 1

```
# 0027. Remove Element

```python
'''
Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:
Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.

Example 2:
Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
'''
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        start, end = 0, len(nums)
        while start < end:
            if nums[start] == val:
                nums[start] = nums[end - 1]
                end -= 1
            else:
                start += 1
        return end

```
# 0028. Implement strStr

```python
# https://leetcode.com/problems/implement-strstr/
#
# Implement strStr().
#
# Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
#
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not needle:
            return 0
        for i in range(len(haystack) - len(needle) + 1):
            if haystack[i:i+len(needle)] == needle:
                return i
        return -1

```
# 0029. Divide Two Integers

```python
'''
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero, which means losing its fractional part.
For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1].
For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.
'''
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        a, b, res = abs(dividend), abs(divisor), 0
        
        while a >= b:
            x = 0
            while a - (b << 1 << x) >= 0:
                x += 1
            res += 1 << x
            a -= b << x
            
        if not (dividend >= 0) is (divisor >= 0):
            res = -res

        return min(max(-2 ** 31, res), 2 ** 31 - 1)
```
# 0030. Substring with Concatenation of All Words

```python
# https://leetcode.com/problems/substring-with-concatenation-of-all-words/
#
# You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
#
from collections import Counter

class Solution:
    def findSubstring(self, s: str, words: list[str]) -> list[int]:
        if not s or not words:
            return []

        word_len = len(words[0])
        num_words = len(words)
        substring_len = word_len * num_words
        word_count = Counter(words)
        res = []

        for i in range(word_len):
            left = i
            count = 0
            seen = Counter()
            for j in range(i, len(s) - word_len + 1, word_len):
                word = s[j:j+word_len]
                if word in word_count:
                    seen[word] += 1
                    count += 1
                    while seen[word] > word_count[word]:
                        left_word = s[left:left+word_len]
                        seen[left_word] -= 1
                        count -= 1
                        left += word_len
                    if count == num_words:
                        res.append(left)
                else:
                    seen.clear()
                    count = 0
                    left = j + word_len
        return res

```
# 0031. Next Permutation

```python
'''
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
'''
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i = len(nums) - 2
        while i >= 0 and nums[i + 1] <= nums[i]:
            i -= 1
        if i >= 0:
            j = len(nums) - 1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        self.reverse(nums, i + 1, len(nums) - 1)
                
    def reverse(self, nums, start, end):
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1

```
# 0032. Longest Valid Parentheses

```python
# https://leetcode.com/problems/longest-valid-parentheses/
#
# Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
#
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        max_len = 0
        for i, char in enumerate(s):
            if char == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    max_len = max(max_len, i - stack[-1])
        return max_len

```
# 0033. Search in Rotated Sorted Array

```python
'''
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
'''
#Method NN
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        
        lower, upper = 0, len(nums) - 1
        
        while lower < upper:
            mid = (lower + upper) // 2
            if nums[mid] > nums[upper]:
                lower = mid + 1
            else:
                upper = mid
                
        if nums[lower] <= target <= nums[-1]:
            return self.binary_search(nums, lower, len(nums) - 1, target)
        else:
            return self.binary_search(nums, 0, lower - 1, target)
        
    def binary_search(self, nums, lower, upper, target):
        
        while lower <= upper:
            mid = (lower + upper) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                upper = mid - 1
            else:
                lower = mid + 1
        return - 1
    
#Method AK
class Solution(object):
    def search(self, nums, target):
        start, end = 0, len(nums) - 1
        while start <= end:
            mid = (start + end)//2
            if nums[mid] == target:
                return mid
            elif nums[start] <= nums[mid]:
                if nums[start] <= target < nums[mid]:
                    end = mid -1
                else:
                    start = mid + 1
            else:
                if nums[end] >= target > nums[mid]:
                    start = mid + 1
                else:
                    end = mid - 1
        return -1

```
# 0034. Find First and Last Position of Element in Sorted Array

```python
'''
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].

NOTE: You must write an algorithm with O(log n) runtime complexity.

Example 1:
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Example 2:
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

Example 3:
Input: nums = [], target = 0
Output: [-1,-1]
 

Constraints:
0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums is a non-decreasing array.
-109 <= target <= 109
'''

from typing import List

# Simple Binary Search

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                if mid == 0 or nums[mid - 1] != target:
                    first = mid
                    break
                right = mid - 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
                
        if left > right:
            return [-1, -1]
                
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                if mid == len(nums) - 1 or nums[mid + 1] != target:
                    last = mid
                    break
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
                
        return [first, last]

# Simple Binary Search in Two Different Functions

class Solution:
    
    def getFirstOccurence(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                if mid == 0 or nums[mid - 1] != target:
                    return mid
                right = mid - 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        return -1
                
    def getLastOccurence(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                if mid == len(nums) - 1 or nums[mid + 1] != target:
                    return mid
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        return -1
    
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        first = self.getFirstOccurence(nums, target)
        last = self.getLastOccurence(nums, target)
        
        return [first, last]

# Simple Binary Search with only one Function

class Solution:
    
    def binarySearch(self, nums, target, flag):
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] > target or (nums[mid] == target and flag):
                high = mid - 1
            else:
                low = mid + 1
        return low if flag else high
    
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.binarySearch(nums, target, True)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        else:
            return [start, self.binarySearch(nums, target, False)]

# Custom Input Check

s = Solution()
answer = s.searchRange([1, 2, 2, 3, 4, 4, 4, 4]) # [4,7]
print(answer)
```
# 0035. Search Insert Position

```python
'''
https://leetcode.com/problems/search-insert-position/
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0
'''

# Using Binary Search

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if target == nums[mid]:
                return mid
            if target > nums[mid]:
                left = mid + 1
            else:
                right = mid
        return left

```
# 0036. Valid Sudoku

```python
# https://leetcode.com/problems/valid-sudoku/
#
# Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
#
# Each row must contain the digits 1-9 without repetition.
# Each column must contain the digits 1-9 without repetition.
# Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.
#
class Solution:
    def isValidSudoku(self, board: list[list[str]]) -> bool:
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        boxes = [set() for _ in range(9)]

        for r in range(9):
            for c in range(9):
                val = board[r][c]
                if val == '.':
                    continue

                if val in rows[r]:
                    return False
                rows[r].add(val)

                if val in cols[c]:
                    return False
                cols[c].add(val)

                box_index = (r // 3) * 3 + (c // 3)
                if val in boxes[box_index]:
                    return False
                boxes[box_index].add(val)
        
        return True

```
# 0037. Sudoku Solver

```python
# https://leetcode.com/problems/sudoku-solver/
#
# Write a program to solve a Sudoku puzzle by filling the empty cells.
#
# A sudoku solution must satisfy all of the following rules:
#
# Each of the digits 1-9 must occur exactly once in each row.
# Each of the digits 1-9 must occur exactly once in each column.
# Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
# The '.' character indicates empty cells.
#
class Solution:
    def solveSudoku(self, board: list[list[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.solve(board)

    def solve(self, board):
        for r in range(9):
            for c in range(9):
                if board[r][c] == '.':
                    for i in range(1, 10):
                        char = str(i)
                        if self.is_valid(board, r, c, char):
                            board[r][c] = char
                            if self.solve(board):
                                return True
                            else:
                                board[r][c] = '.'
                    return False
        return True

    def is_valid(self, board, row, col, char):
        for i in range(9):
            if board[row][i] == char:
                return False
            if board[i][col] == char:
                return False
            if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == char:
                return False
        return True

```
# 0038. Count and Say

```python
'''
The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.

Note: Each term of the sequence of integers will be represented as a string.

 

Example 1:

Input: 1
Output: "1"
Explanation: This is the base case.

Example 2:

Input: 4
Output: "1211"
Explanation: For n = 3 the term was "21" in which we have two groups "2" and "1", "2" can be read as "12" which means frequency = 1 and value = 2, the same way "1" is read as "11", so the answer is the concatenation of "12" and "11" which is "1211".
'''
class Solution(object):
    def countAndSay(self, n):
        if n == 1:
            return '1'
        s = '1'
        for _ in range(n - 1):
            cur_val, count, res = s[0], 0, []
            for i in s:
                if cur_val == i:
                    count += 1
                else:
                    res.append(str(count))
                    res.append(cur_val)
                    cur_val = i
                    count = 1
            res.append(str(count))
            res.append(cur_val)
            s = ''.join(res)
        return s

```
# 0039. Combination Sum

```python
'''
Given an array of distinct integers candidates and a target integer target,
return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times.
Two combinations are unique if the frequency of at least one of the chosen numbers is different.
It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:
Input: candidates = [2], target = 1
Output: []

Example 4:
Input: candidates = [1], target = 1
Output: [[1]]

Example 5:
Input: candidates = [1], target = 2
Output: [[1,1]]
 

Constraints:
1 <= candidates.length <= 30
1 <= candidates[i] <= 200
All elements of candidates are distinct.
1 <= target <= 500
'''

# Using Backtracking

class Solution:
    
    def backtrack(self, candidates, target, res, cur, index, summ):
        if summ == target:
            res.append(cur[:])
        elif summ < target:
            for i in range(index, len(candidates)):
                cur.append(candidates[i])
                self.backtrack(candidates, target, res, cur, i, sum(cur))
                cur.pop()
        return
    
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        cur = []
        self.backtrack(candidates, target, res, cur, 0, 0)
        return res
```
# 0040. Combination Sum II

```python
# https://leetcode.com/problems/combination-sum-ii/
#
# Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
#
# Each number in candidates may only be used once in the combination.
#
# Note:
#
# All numbers (including target) will be positive integers.
# The solution set must not contain duplicate combinations.
#
class Solution:
    def combinationSum2(self, candidates: list[int], target: int) -> list[list[int]]:
        candidates.sort()
        res = []
        self.dfs(candidates, target, 0, [], res)
        return res

    def dfs(self, nums, target, index, path, res):
        if target < 0:
            return
        if target == 0:
            res.append(path)
            return
        for i in range(index, len(nums)):
            if i > index and nums[i] == nums[i-1]:
                continue
            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], res)

```
# 0041. First Missing Positive

```python
# https://leetcode.com/problems/first-missing-positive/
#
# Given an unsorted integer array, find the smallest missing positive integer.
#
class Solution:
    def firstMissingPositive(self, nums: list[int]) -> int:
        n = len(nums)
        for i in range(n):
            while 0 < nums[i] <= n and nums[nums[i]-1] != nums[i]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
        
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        
        return n + 1

```
# 0042. Trapping Rain Water

```python
# https://leetcode.com/problems/trapping-rain-water/
#
# Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
#
class Solution:
    def trap(self, height: list[int]) -> int:
        if not height:
            return 0
        
        left, right = 0, len(height) - 1
        left_max, right_max = height[left], height[right]
        water = 0
        
        while left < right:
            if left_max < right_max:
                left += 1
                left_max = max(left_max, height[left])
                water += left_max - height[left]
            else:
                right -= 1
                right_max = max(right_max, height[right])
                water += right_max - height[right]
                
        return water

```
# 0043. Multiply Strings

```python
# https://leetcode.com/problems/multiply-strings/
#
# Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
#
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if "0" in [num1, num2]:
            return "0"
        
        res = [0] * (len(num1) + len(num2))
        num1, num2 = num1[::-1], num2[::-1]
        
        for i1 in range(len(num1)):
            for i2 in range(len(num2)):
                digit = int(num1[i1]) * int(num2[i2])
                res[i1 + i2] += digit
                res[i1 + i2 + 1] += res[i1 + i2] // 10
                res[i1 + i2] = res[i1 + i2] % 10

        res, beg = res[::-1], 0
        while beg < len(res) and res[beg] == 0:
            beg += 1
            
        return "".join(map(str, res[beg:]))

```
# 0044. Wildcard Matching

```python
# https://leetcode.com/problems/wildcard-matching/
#
# Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
#
# '?' Matches any single character.
# '*' Matches any sequence of characters (including the empty sequence).
# The matching should cover the entire input string (not partial).
#
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = True
        
        for j in range(1, len(p) + 1):
            if p[j-1] == '*':
                dp[0][j] = dp[0][j-1]

        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if p[j-1] == '*':
                    dp[i][j] = dp[i-1][j] or dp[i][j-1]
                elif p[j-1] == '?' or s[i-1] == p[j-1]:
                    dp[i][j] = dp[i-1][j-1]
        
        return dp[-1][-1]

```
# 0045. Jump Game II

```python
# https://leetcode.com/problems/jump-game-ii/
#
# Given an array of non-negative integers, you are initially positioned at the first index of the array.
#
# Each element in the array represents your maximum jump length at that position.
#
# Your goal is to reach the last index in the minimum number of jumps.
#
class Solution:
    def jump(self, nums: list[int]) -> int:
        jumps = 0
        cur_end = 0
        farthest = 0
        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])
            if i == cur_end:
                jumps += 1
                cur_end = farthest
        return jumps

```
# 0046. Permutations

```python
'''
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
'''

# Using Backtracking

class Solution:
    
    def backtrack(self, nums, res, cur):
        if not nums:
            res.append(cur)
        for i in range(len(nums)):
            self.backtrack(nums[:i] + nums[i+1:], res, cur + [nums[i]])
    
    def permute(self, nums: List[int]) -> List[List[int]]:
        cur = []
        res = []
        self.backtrack(nums, res, cur)
        return res
```
# 0047. Permutations II

```python
# https://leetcode.com/problems/permutations-ii/
#
# Given a collection of numbers that might contain duplicates, return all possible unique permutations.
#
class Solution:
    def permuteUnique(self, nums: list[int]) -> list[list[int]]:
        nums.sort()
        res = []
        self.dfs(nums, [], res)
        return res

    def dfs(self, nums, path, res):
        if not nums:
            res.append(path)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)

```
# 0048. Rotate Image

```python
'''
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.
DO NOT allocate another 2D matrix and do the rotation.
 
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

Example 3:
Input: matrix = [[1]]
Output: [[1]]

Example 4:
Input: matrix = [[1,2],[3,4]]
Output: [[3,1],[4,2]]
 

Constraints:
matrix.length == n
matrix[i].length == n
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000
'''
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        
        for i in range(n):
            j = i
            while j < n:
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
                j += 1
                
        for i in range(n):
            for j in range(n//2):
                matrix[i][j], matrix[i][n - 1 - j] = matrix[i][n - 1 - j], matrix[i][j]
```
# 0049. Group Anagrams

```python
'''
Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
Example 2:

Input: strs = [""]
Output: [[""]]
Example 3:

Input: strs = ["a"]
Output: [["a"]]
 

Constraints:

1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] consists of lower-case English letters.
'''

from typing import List

# Using Hash Table without sorting

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for s in strs:
            key = [0] * 26
            for c in s:
                key[ord(c) - ord('a')] += 1
            key = tuple(key)
            if key in d:
                d[key].append(s)
            else:
                d[key] = [s]
        return d.values()

# Using Sorting and Hash Table 

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d= {}
        for s in strs:
            key = sorted(s)
            key = ''.join(key)
            if key in d:
                d[key].append(s)
            else:
                d[key] = [s]
        result = []
        for key, value in d.items():
            result.append(value)
        return result

# Using function to find Hash in Hash Table

class Solution:
    
    def findHash(self, s):
        return ''.join(sorted(s))
    
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for s in strs:
            key = self.findHash(s)
            if key in d:
                d[key].append(s)
            else:
                d[key] = [s]
        return d.values()

# Custom Input Check

s = Solution()
answer = s.findHash(["tan","ant","act","cat"]) # [["tan","ant"],["act","cat"]]
print(answer)
```
# 0050. Pow x n

```python
# https://leetcode.com/problems/powx-n/
#
# Implement pow(x, n), which calculates x raised to the power n (xn).
#
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return 1 / self.myPow(x, -n)
        if n % 2 == 0:
            return self.myPow(x*x, n//2)
        return x * self.myPow(x*x, (n-1)//2)

```
