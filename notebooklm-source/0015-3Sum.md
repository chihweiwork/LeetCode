# 0015 - 3Sum (三數之和)

## 1. 題目理解 (Problem Comprehension)

給你一個包含 `n` 個整數的陣列 `nums`，判斷 `nums` 中是否存在三個元素 `a, b, c`，使得 `a + b + c = 0`？

請找出所有和為 0 且**不重複**的三元組。

**輸入與輸出格式：**
*   **輸入 (Input):** `nums`: 整數列表。
*   **輸出 (Output):** 所有不重複的三元組列表 (List[List[int]])。

**限制：**
*   答案中不可以包含重複的三元組。

**範例：**
`nums = [-1, 0, 1, 2, -1, -4]`
輸出: `[[-1, -1, 2], [-1, 0, 1]]`

## 2. 思路分析 (Thought Process)

### 直觀解法：暴力法
使用三層迴圈遍歷所有組合，然後用一個 Set 來去除重複。
*   時間複雜度：O(N^3)。
*   空間複雜度：O(N) 用於儲存結果。
這在面試中通常是不可接受的，因為 N 如果是 3000，N^3 會達到 270 億，遠超運算限制。

### 優化思路：排序 + 雙指針 (Sorting + Two Pointers)
如果我們能把三數之和簡化為「兩數之和」，問題就會變簡單。

1.  **排序**：先將 `nums` 從小到大排序。排序是處理「重複」的關鍵。
2.  **固定一個數**：遍歷陣列，假設目前的數是 `nums[i]`。
3.  **尋找另外兩個數**：在 `nums[i]` 之後的區間 `[i+1, n-1]` 中，使用雙指針 `left` 和 `right` 尋找兩個數，使得 `nums[left] + nums[right] = -nums[i]`。
    *   如果和太小，`left` 右移。
    *   如果和太大，`right` 左移。
    *   如果正好相等，記錄答案，並跳過所有重複的 `nums[left]` 和 `nums[right]`。

**如何避免重複？**
*   當固定 `nums[i]` 時，如果 `nums[i] == nums[i-1]`，則直接跳過這次迴圈。
*   當找到一組解後，移動 `left` 和 `right` 時，也要跳過相同的數字。

## 3. 演算法設計 (Algorithm Design)

我們採用 **排序 + 雙指針** 的方法。

**偽代碼 (Pseudo-code):**

```text
Function threeSum(nums):
    Sort nums
    Initialize res = []
    n = length(nums)

    For i from 0 to n - 3:
        # 避免重複
        If i > 0 AND nums[i] == nums[i-1]:
            Continue
        
        # 雙指針尋找剩下兩數
        left = i + 1
        right = n - 1
        While left < right:
            total = nums[i] + nums[left] + nums[right]
            If total == 0:
                Add [nums[i], nums[left], nums[right]] to res
                # 再次避免重複
                While left < right AND nums[left] == nums[left+1]: left++
                While left < right AND nums[right] == nums[right-1]: right--
                left++
                right--
            Else if total < 0:
                left++
            Else:
                right--

    Return res
```

**複雜度分析：**

*   **時間複雜度 (Time Complexity): O(N^2)**
    *   排序需要 O(N log N)。
    *   外部迴圈跑 N 次，內部雙指針跑 N 次，總共 O(N^2)。
*   **空間複雜度 (Space Complexity): O(log N)** 到 **O(N)**
    *   取決於排序演算法所需的空間。在 Python 中通常是 O(N)。

## 4. 程式碼實現與註解 (Code Implementation with Comments)

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 1. 首先對陣列進行排序，這是使用雙指針的前提
        nums.sort()
        res = []
        n = len(nums)
        
        # 2. 遍歷陣列，固定第一個數字 nums[i]
        # 我們只需要遍歷到倒數第三個，因為後面要留兩個位置給 left 和 right
        for i in range(n - 2):
            # 如果目前數字大於 0，因為後面的數字只會更大，
            # 所以三數之和不可能等於 0，可以直接結束
            if nums[i] > 0:
                break
            
            # 關鍵：跳過重複的固定數字，避免結果出現重複的三元組
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            
            # 3. 在固定 nums[i] 的情況下，使用雙指針尋找剩下的兩個數
            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                
                if total < 0:
                    # 和太小，左指針往右移以增加數值
                    left += 1
                elif total > 0:
                    # 和太大，右指針往左移以減少數值
                    right -= 1
                else:
                    # 找到了符合條件的三元組
                    res.append([nums[i], nums[left], nums[right]])
                    
                    # 關鍵：找到答案後，跳過左右指針指向的重複數字
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    
                    # 兩邊指針同時收縮
                    left += 1
                    right -= 1
                    
        return res
```