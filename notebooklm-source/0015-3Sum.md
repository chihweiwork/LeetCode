# LeetCode #15 - 3Sum (三數之和) 教學

嗨，同學！這一次我們要挑戰一個非常有代表性的中等難度題目：LeetCode 第 15 題 - 3Sum。這題是 `2Sum` 問題的延伸，是面試中的常客，掌握它對於理解如何優化複雜度非常有幫助。

## 1. 題目理解

題目給我們一個整數陣列 `nums`，要求我們找出其中所有**不重複**的三元組 `(a, b, c)`，使得 `a + b + c = 0`。

注意關鍵字：**不重複**。這意味著：
-   `[-1, 0, 1]` 和 `[0, -1, 1]` 是同一個三元組。
-   如果輸入是 `[-1, -1, 0, 1, 2]`，`[-1, 0, 1]` 這個組合只需要輸出一次。

## 2. 思考過程 & 演算法選擇

### 方法一：暴力解法

最直接的想法就是窮舉所有可能的三元組。
-   用第一個迴圈 `i` 來選第一個數。
-   用第二個迴圈 `j` (從 `i+1` 開始) 來選第二個數。
-   用第三個迴圈 `k` (從 `j+1` 開始) 來選第三個數。
-   檢查 `nums[i] + nums[j] + nums[k]` 是否等於 0。

這個方法的時間複雜度是 **O(n³)**。對於 LeetCode 的測試規模來說，這絕對會超時。更麻煩的是，處理「不重複」會變得很棘手，你可能需要用一個 Set 來儲存排序後的元組，程式碼會很複雜。

我們需要一個更高效的方法。

### 方法二：排序 + 雙指針 (The Optimal Approach)

這題的最佳解法是將問題降維打擊！我們可以將 `3Sum` 問題轉換成 `n` 個 `2Sum` 問題。

**核心思路：**
1.  **先排序！** 這是整個演算法的基石。排序讓我們能用雙指針，並且能輕鬆地跳過重複項。
2.  用一個 `for` 迴圈來固定第一個數 `nums[i]`。
3.  對於每一個 `nums[i]`，我們需要在它**右邊**的數組部分找到兩個數 `nums[left]` 和 `nums[right]`，使得 `nums[left] + nums[right] == -nums[i]`。
4.  這就變成了一個 `2Sum` 問題！我們可以使用**雙指針**技巧來解決它。

**演算法步驟：**

1.  **排序陣列** `nums`。
2.  遍歷 `nums`，用 `i` 從 `0` 到 `n-3`。`i` 代表我們固定的第一個數。
    -   **優化 & 去重 1**：如果 `nums[i]` 和前一個數 `nums[i-1]` 相同，那麼以 `nums[i]` 為首的所有組合都已經在 `nums[i-1]` 的時候找過了，直接 `continue` 跳過。
    -   **優化 2**：如果 `nums[i]` 已經大於 0，因為陣列是排好序的，後面的數只會更大，所以三個正數相加不可能等於 0。可以直接 `break` 結束整個迴圈。

3.  在 `for` 迴圈內部，設定**雙指針**：
    -   `left = i + 1`
    -   `right = n - 1` (陣列結尾)

4.  啟動 `while left < right` 迴圈：
    -   計算三數之和 `total = nums[i] + nums[left] + nums[right]`。
    -   如果 `total < 0`，說明和太小了，我們需要一個更大的數，所以 `left += 1`。
    -   如果 `total > 0`，說明和太大了，我們需要一個更小的數，所以 `right -= 1`。
    -   如果 `total == 0`，恭喜！找到一個三元組。
        -   將 `[nums[i], nums[left], nums[right]]` 加入結果列表。
        -   **去重 3 (關鍵)**：現在我們要移動 `left` 和 `right` 指針來尋找新的可能。但如果 `nums[left]` 後面還有幾個一樣的數，或者 `nums[right]` 前面還有幾個一樣的數，它們會產生重複的三元組。所以：
            -   用一個 `while` 迴圈跳過所有和 `nums[left]` 相同的後續元素。
            -   用另一個 `while` 迴圈跳過所有和 `nums[right]` 相同的前續元素。
        -   完成去重後，將 `left` 和 `right` 各移動一步，繼續尋找。

5.  `for` 迴圈結束後，返回結果列表。

這個演算法的時間複雜度是多少呢？
-   排序：O(n log n)
-   外層迴圈：O(n)
-   內層雙指針迴圈：O(n)
-   總體是 O(n log n) + O(n²)，所以最終時間複雜度是 **O(n²)**。這比 O(n³) 好太多了！

## 3. 程式碼實現

這是在 `mylearning/0015-3Sum.py` 中的解答：

```python
from typing import List

class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
    result = []
    # 1. 排序是關鍵的第一步
    nums.sort()
    
    n = len(nums)
    
    # 2. 遍歷陣列，固定第一個數 nums[i]
    for i in range(n - 2):
      # 優化：如果最小的數都大於0，不可能相加為0
      if nums[i] > 0:
        break
        
      # 去重：如果當前數字和前一個相同，則跳過，避免重複計算
      if i > 0 and nums[i] == nums[i-1]:
        continue
      
      # 3. 設定雙指針
      left, right = i + 1, n - 1
      
      while left < right:
        total = nums[i] + nums[left] + nums[right]
        
        if total < 0:
          left += 1 # 和太小，左指針右移
        elif total > 0:
          right -= 1 # 和太大，右指針左移
        else:
          # 找到了！
          result.append([nums[i], nums[left], nums[right]])
          
          # 關鍵去重步驟
          while left < right and nums[left] == nums[left + 1]:
            left += 1
          while left < right and nums[right] == nums[right - 1]:
            right -= 1
            
          # 移動指針，尋找下一個可能的組合
          left += 1
          right -= 1
          
    return result
```

3Sum 是一個里程碑式的題目，務必花時間徹底理解排序和雙指針如何協同工作，以及每一步去重操作的必要性。恭喜你完成了這次的挑戰！
