# 0018 - 4Sum (四數之和)

## 1. 題目理解 (Problem Comprehension)

給你一個由 `n` 個整數組成的陣列 `nums` ，和一個目標值 `target` 。

請你找出並返回滿足下述全部條件的所有**不重複**四元組 `[nums[a], nums[b], nums[c], nums[d]]` ：
*   `0 <= a, b, c, d < n`
*   `a, b, c, d` 互不相同
*   `nums[a] + nums[b] + nums[c] + nums[d] == target`

**輸入與輸出格式：**
*   **輸入 (Input):** `nums`: 整數列表, `target`: 目標值。
*   **輸出 (Output):** 四元組列表。

**範例：**
`nums = [1, 0, -1, 0, -2, 2], target = 0`
輸出: `[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`

## 2. 思路分析 (Thought Process)

這道題是 `3Sum` 的進階版。核心思路非常相似：**排序 + 多層迴圈 + 最內層雙指針**。

**策略：**
1.  **排序**：將陣列由小到大排序。
2.  **固定前兩個數**：
    *   第一層迴圈固定 `nums[i]`。
    *   第二層迴圈固定 `nums[j]` (從 `i+1` 開始)。
3.  **雙指針尋找後兩個數**：
    *   在 `[j+1, n-1]` 範圍內，使用 `left` 和 `right` 指針。
    *   尋找滿足 `nums[i] + nums[j] + nums[left] + nums[right] == target` 的組合。
4.  **去重**：在每一層迴圈中，如果當前的數字與前一個數字相同，則跳過。

### 優化技巧 (剪枝)
由於陣列已經排序，我們可以加入一些邏輯提早結束不必要的計算：
*   **如果目前最小的四數之和都大於 target**：剩下的組合只會更大，直接 `break`。
*   **如果目前最大的四數之和都小於 target**：目前的 `i` 或 `j` 太小了，直接 `continue` 到下一個。

## 3. 演算法設計 (Algorithm Design)

我們採用 **兩層迴圈 + 雙指針**。

**偽代碼 (Pseudo-code):**

```text
Function fourSum(nums, target):
    Sort nums
    res = []
    
    For i from 0 to n - 4:
        # 去重
        If i > 0 and nums[i] == nums[i-1]: Continue
        
        # 剪枝優化...
        
        For j from i + 1 to n - 3:
            # 去重
            If j > i + 1 and nums[j] == nums[j-1]: Continue
            
            # 雙指針
            left = j + 1
            right = n - 1
            While left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                If total == target:
                    Add to res
                    # 去重並收縮指針
                    ...
                Else if total < target:
                    left++
                Else:
                    right--
    Return res
```

**複雜度分析：**

*   **時間複雜度 (Time Complexity): O(N^3)**
    *   兩層迴圈加上一層雙指針。
*   **空間複雜度 (Space Complexity): O(1)** (或排序所需的 O(N))。

## 4. 程式碼實現與註解 (Code Implementation with Comments)

```python
from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        # 1. 排序是處理不重複組合的關鍵
        nums.sort()
        n = len(nums)
        res = []
        
        # 2. 第一層迴圈：固定第一個數
        for i in range(n - 3):
            # 跳過重複的數字
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            
            # [優化] 如果目前最小的四個數相加都大於目標，後面沒戲了
            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:
                break
            # [優化] 如果目前數字加上最大的三個數都還小於目標，則當前 i 太小
            if nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target:
                continue
                
            # 3. 第二層迴圈：固定第二個數
            for j in range(i + 1, n - 2):
                # 跳過重複的數字
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                
                # [優化] 針對 j 的剪枝
                if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target:
                    break
                if nums[i] + nums[j] + nums[n-2] + nums[n-1] < target:
                    continue
                
                # 4. 雙指針法：尋找最後兩個數
                left, right = j + 1, n - 1
                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    if total < target:
                        left += 1
                    elif total > target:
                        right -= 1
                    else:
                        # 找到一組解
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        # 跳過重複的左指針和右指針
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                        
        return res
```
